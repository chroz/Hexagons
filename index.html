<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="apple-touch-icon" href="apple-touch-icon.png">
        <!-- Place favicon.ico in the root directory -->

        <link rel="stylesheet" href="css/normalize.css">
        <link rel="stylesheet" href="css/main.css">
        <link rel="stylesheet" href="css/hex.css">

        <script type="text/javascript" src="js/vendor/modernizr-2.8.3.min.js"></script>
        <script type="text/javascript" src="script/dist/paper-full.js"></script>
    </head>
    <body>
     <!-- Define inlined PaperScript associate it with myCanvas -->

        <canvas id="myCanvas" resize width="600" height="600"></canvas>

        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
        <script type="text/javascript">window.jQuery || document.write('<script src="js/vendor/jquery-1.11.3.min.js"><\/script>')</script>
        <script type="text/javascript" src="js/plugins.js"></script>
        <script type="text/javascript" src="js/main.js"></script>

        <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
        <script type="text/javascript">
            (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
            function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
            e=o.createElement(i);r=o.getElementsByTagName(i)[0];
            e.src='https://www.google-analytics.com/analytics.js';
            r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
            ga('create','UA-XXXXX-X','auto');ga('send','pageview');
        </script>

    <script type="text/paperscript" canvas="myCanvas">


        /**
            @param i - number in the row
            @param rownumber
            @param xoffset
        **/

        function getHexCoordinate(i, rownumber, xoffset) {

            // The y coordinate always corresponds directly to the row number
            // the x coordinate decreases by 1 for every row
            // assuming the new block is directly Southwest of the corresponding block number
            // if it is not directly southwest, use xoffset to adjust it

            x = i - rownumber + xoffset;
            return { x : x , y: rownumber };
        }



        var Game = function (radius, generator) {
            var game = this;
            this.radius = radius;
            this.normal_length = Math.sqrt(radius*radius - (radius/2) * (radius/2));

            this.spawnHex = function () {

                var colors = [new Color(1,.3,.3), new Color (.3,1,.3), new Color(.3,.3,1), new Color(1,1,.3), new Color(1,.3,1)];

                var color = Math.floor(Math.random()*colors.length);

                var shape = new Path.RegularPolygon(new Point(0, 0), 6, radius);
                shape.fillColor = colors[color];
                shape.strokeColor = new Color (0,0,0)
                shape.strokeWidth = 2;

                shape.shadowColor = new Color(0, 0, 0);
                shape.shadowBlur = 12;
                shape.shadowOffset = new Point(5, 5);
                shape.name = 'hexagon';
                var text = new paper.PointText(10,30).rotate(-30);
                text.name = 'text';

                text.content = '';
                text.opacity = 0.8;

                var hexagon = new paper.Group();    
                hexagon.addChild(shape);  
                hexagon.addChild(text);         

                hexagon.onMouseDown = function (e) {
                   game.board.mark(hexagon);
                }
                hexagon.onMouseEnter = function (e){
                  if (dragging) {
                    game.board.mark(hexagon);
                  }
                };
                
                hexagon._type = 'P';

                return hexagon; 
            };


            var Hole = function () {
                this._type  = 'H';
                return this;
            }            

            var Board = function (generator) {

                var board = this;

                /* rewrite this fugly thing */
                this.getAbsolutePosition = function (numhexagons, x,y) {
                  var offsetfromleft = game.normal_length + game.normal_length * (7 - numhexagons);
                  return { x : offsetfromleft + game.normal_length*2*x, y: radius + radius*1.5*y};
                }

                this.isInside = function (i,j) {
                    return this.slots[j] && this.slots[j][i];
                }

                this.isOutside = function (i,j) {
                    return !this.isInside(i,j);
                }

                this.isHole = function (i,j) {
                    if (this.isOutside(i,j)) throw "Utafor, næpskrell";
                    var obj = this.slots[j] && this.slots[j][i]; 
                    return obj.type == 'H';
                }

                this.isTile = function (i,j) {
                    if (this.isOutside(i,j)) throw "Utafor, næpskrell";
                    var obj = this.slots[j] && this.slots[j][i];
                    if (!obj) throw "No object defined at " + i + ' ' + j;
                    return obj._type == 'P';
                };


                this.getTileAt = function (i,j) {
                    if (board.isTile(i,j)) {
                        return this.slots[j][i];
                    }
                    throw 'Not a tile at ' + i + ' ' + j;
                }

                this.insertAt = function (i, j, obj) {
                    if (this.isOutside(i,j)) throw "Utafor, næpskrell";  
                    if (!obj || !(obj._type == 'P' || obj._type == 'H')) {
                        throw 'Must be a polygon or hole';
                    }

                    var old = this.slots[j][i];
                    obj.position = old.position;
                    obj._i = i;
                    obj._j = j;
                    if (obj._type == 'P') 
                        obj.getItem({name : 'text'}).content = i + ',' + j;
                    this.slots[j][i] = obj;
                    return obj;
                }

                this.removeTileAt = function (i,j) {

                    console.log ('removing tile at ' + i + ' ' + j);

                    var tile = this.getTileAt(i,j);
                  //  tile.remove();
                    var hole = this.insertAt (i,j, new Hole());
                    board.holes.push(hole);
                    return tile;
                }


                this.getMarked = function () {
                    return board.marked;
                }

                this.removeMarked = function () {

                    if (board.marked.length < 2) {
                        throw "Minst to brikker";
                    }

                    var A = board.marked [board.marked.length-1];
                    var B = board.marked [board.marked.length-2];

                    var dir = board.getDirection(A,B);
                    dir = board.getReverseDirection(dir);

                    $(board.marked).each(function (i,e) {
                        var t = board.removeTileAt(e._i, e._j);
                        t.remove();
                     });
                    board.marked = [];

                    board.fillBoard (dir);
                };

                this.mark = function (tile) {
                    tile.fillColor = new Color(.7,.7,.3);
                    if (!tile._marked) {
                        tile._marked = true;
                        board.marked.push (tile);                       
                    }
                }

                this.getDirection = function (obj, obj2) {
                   var dx = obj._i - obj2._i;
                   var dy = obj._j - obj2._j;
                   return {x: dx, y: dy};
                }

                this.getReverseDirection = function (dir) {
                    return inverteddir = {x: -dir.x, y: - dir.y};
                }

                this.redraw = function () {
                    paper.project._needsUpdate = true;
                    paper.project.view.update();
                };


                this.fillBoard = function (direction) {

                    var holes = board.getHoles();

                    var doFill = function (hole) {

                        var i = hole._i;
                        var j = hole._j;

                        var tile = findFirstTile(i,j, direction);
                        if (tile) {
                            board.removeTileAt(tile._i,tile._j);
                        } else {
                            tile = game.spawnHex();
                        }
                        
                        window.setTimeout(function () {
                            board.insertAt(i,j, tile);
                            board.redraw();

                            if (holes.length) {
                                return doFill (holes.pop());
                            } else {
                                holes = board.getHoles();
                                if (holes.length)
                                    return doFill (holes.pop());
                                return;
                            }
                        }, 300);


                    }
                    doFill(holes.pop());
                }


                var findFirstTile = function (i, j, dir) {
      
                   var i = i + dir.x;
                   var j = j + dir.y;

                   if (board.isOutside(i,j)) {
                     return null;
                   }

                   if (board.isTile(i,j)) {
                     return board.getTileAt(i,j);
                   }

                   return findFirstTile(i,j, dir);
                }


                this.getHoles = function () {
                    return this.holes;
                }


                this.holes = [];
                this.tiles = [];
                this.marked = [];

                this.slots = {};

                var lastrowlength = generator[0];
                for (var y =0; y<generator.length; y++) {
                    var numhexagons = generator[y];
                    for (var x = 0; x<numhexagons; x++ ) {
                        var hex = game.spawnHex();
                        var A = numhexagons - lastrowlength;
                        var offset = 0;
                        /* Dette må forstås altså */
                        if (A<0) {
                            offset = 7 - numhexagons + A + 1;
                        }

                        var i = x - y + offset;
                        var j = y;

                        if (this.slots[j] == undefined) {
                            this.slots[j] = {};
                        }
                        this.slots[j][i] = hex;

                        hex.getItem({name : 'text'}).content = i + ',' + j;

                        hex._i = i;
                        hex._j = j;
                        hex._type = 'P';

                        var pos = this.getAbsolutePosition(numhexagons, x,y);
                        hex.position = pos;
                    } 
                    lastrowlength = numhexagons;
                }
            }
            this.board = new Board(generator);
        };

        var game = new Game(40, [4,5,6,7,6,5,4]);



/*



    var radius = 40;
    
    var COLOR1 = 0;
    var COLOR2 = 1;
    var COLOR3 = 2;
    var COLOR4 = 3;
    var COLOR5 = 5; 

    var colors = [new Color(1,0,0), new Color (0,1,0), new Color(0,0,1), new Color(1,1,0), new Color(1,0,1)];
   

    function hex () {
  
      var hexagon = new Path.RegularPolygon(new Point(0, 0), 6, radius);
         hexagon.fillColor = '#e9e9ff';
      return hexagon; 

    }

    var width = 7;
    var height = 7; 

    var marked = [];
    var board = [];

    var x = radius;
    var y = radius;

    // Avstand fra sentrum til kanten på hexagonet (ikke hjørnet)
     
    var edge_distance = Math.sqrt(radius*radius - (radius/2) * (radius/2));

    var xoff = edge_distance;
    var yoff = radius;

    var grid_max_width = 7;

    function getAbsolutePos(numhexagons, x,y) {
      
      var offsetfromleft = edge_distance + edge_distance * (grid_max_width - numhexagons);
      
      var xoff = edge_distance*offsetfromleft;

      return { x : offsetfromleft + edge_distance*2*x, y: yoff + radius*1.5*y};
    }


    function getGridReference(celloffset,x,y) {
        x = x - y;
        x += celloffset;
        return { x : x , y: y };
    }

    var Grid = {};



    function generateGrid () {

        var generator = [4,5,6,7,6,5,4];


        var _grid = {};

        _grid.board = [];

        _grid.getAbsolutePosition = function (coords) {
            var pos;
            $(this.board).each(function (i,e) {
                if (e.coord.x == coords.x && e.coord.y == coords.y) {
                    pos = e.abspos;
                    return false;
                }
            });
            return pos;
        }

        _grid.getTile = function (x,y) { // Stygg funksjon, fikse senere din tosk
          //  console.log ('gettile '+ x + ' ' +y)

            var self = this;
            if ( y<0 || y >= generator.length) {// console.log ('ycoord off')
                return false;
            }
            for (var i = 0; i<self.board.length; i++) {
                var slot = self.board[i];

                if (slot === undefined) {
                    continue;
                }
            //    console.log (slot);
                if (slot.coord.x == x && slot.coord.y == y) {
                    if (slot.hexagon) return slot.hexagon;
                    else return false;
//                    return slot.hexagon;
                }
            }

            return false;
        };


        var board = [];
        var lastrowlength = generator[0];

        for (var y =0; y<generator.length; y++) { break;
          
          xoff = edge_distance;
          var numhexagons = generator[y];

          for (var x = 0; x<numhexagons; x++ ) {

            var h = hex();
          
            var A = grid_max_width - numhexagons;
            var B = numhexagons - lastrowlength;

            var offset = 0;
            if (B<0) {
                offset = A + B + 1;
            }


            h.gridref = getGridReference(offset, x,y);
            var pos = getAbsolutePos(numhexagons, x,y);
            
            h.position.x = pos.x;
            h.position.y = pos.y;

            var entry = {
                coord : h.gridref,
                abspos: pos,
                hexagon : h
            };

            board.push(entry); 

            h.x = x;
            h.y = y;

            h.strokeColor = new Color (0,0,0)
            h.strokeWidth = 2;
            h.color = Math.floor(Math.random()*colors.length);
            h.fillColor = colors[h.color]; 
            h.shadowColor = new Color(0, 0, 0);
            h.shadowBlur = 12;
            h.shadowOffset = new Point(5, 5);

            var text = new PointText({
                point: [pos.x,pos.y],
                content: h.gridref.x + ',' + h.gridref.y,
                fillColor: 'black',
                fontFamily: 'Courier New',
                fontWeight: 'bold',
                fontSize: 12
            });

            h.onMouseDown = function (e) {
              mark(this);
            }
        
            h.onMouseEnter = function (e){
              if (dragging) {
                mark(this);
              }
            };

         } 
         lastrowlength = numhexagons;
       }
       _grid.board = board;
       return _grid;
   }
   
   var Grid = generateGrid();

   window.Grid = Grid;

   function mark(hexagon) {
     hexagon.fillColor = new Color(.7,.7,.3);

     for (var i =0; i<marked.length; i++) {
        if (marked[i] == hexagon) return false;
     }

     marked.push (hexagon);
   }

   function removeFromBoard () {


     var holes = [];

     $(marked).each(function (i,e) {
       e.remove();
       holes.push(e.gridref);
     });

    var a = marked[marked.length-1];
    var b = marked[marked.length-2];

    var dir = getDirection (a, b);
    var inverteddir = {x: -dir.x, y: - dir.y};
    
    //Her kan en slenge logikk for poeng, antall brikker, bla blah
    fillBoard(holes, inverteddir);

     marked = [];
   }

*/
/*
  function createHex () {
  
    var h = hex();
    //Grid.board.push(h);

    h.strokeColor = new Color (0,0,0)
    h.strokeWidth = 2;
    h.color = Math.floor(Math.random()*colors.length);
    h.fillColor = colors[h.color]; 
    h.shadowColor = new Color(0, 0, 0);
    h.shadowBlur = 12;
    h.shadowOffset = new Point(5, 5);


    h.onMouseDown = function (e) {
      mark(this);
    }

    h.onMouseEnter = function (e){
      if (dragging) {
        mark(this);
      }
    };

    return h;
  }
 
        
    function getDirection(h1, h2) {
      var dx = h1.gridref.x - h2.gridref.x;
      var dy = h1.gridref.y - h2.gridref.y;

     return {x: dx, y: dy};
    }
 

   function fillBoard(holes, filldirection) {


    var doFill = function (hole) {


            var tile = findTile(hole, filldirection);
            var position = Grid.getAbsolutePosition(hole);


            if (!tile) { // utafor kartet, siste tile.
               var newHex = createHex();
               newHex.gridref  = hole;
               newHex.position = position;
                paper.project._needsUpdate = true;
                paper.project.view.update();
            } else {
                var temp = {x : tile.gridref.x, y: tile.gridref.y};

               // console.log ('moving tile to ' + hole.x + ' ' + hole.y );

                tile.gridref  = hole;
                tile.position = position;

              //  console.log ('generating hole at ' + temp.x + ' ' + temp.y); 
                holes.unshift(temp);
            }

            if (holes.length) {
                 window.setTimeout (function () {
                    paper.project._needsUpdate = true;
                    paper.project.view.update();
                   doFill(holes.pop());
                 }, 200);
           }
            
    }
    //Begynner med siste hexagon i lista
    doFill(holes.pop());

    function findTile(hole, dir) {
       // Gå i gridet i spesifisert retning 

       var x = hole.x + dir.x;
       var y = hole.y + dir.y;


       for (var i=0; i< holes.length; i++) {
            var hole = holes[i];
            if (hole.x == x && hole.y == y) {
                return findTile(hole, dir);
            }
        }
         return Grid.getTile(x,y);
    }

   }
*/
tool.minDistance = 10;
tool.maxDistance = 45;

var path;
var dragging = false;


function onMouseDown(event) {
    dragging = true;


    path = new Path();
    path.fillColor = {
        hue: 1,
        saturation: 1,
        brightness: 0
    };

    path.add(event.point);
}

function onMouseDrag(event) {
    var step = event.delta / 2;
    step.angle += 90;
    
    var top = event.middlePoint + step;
    var bottom = event.middlePoint - step;
    
    path.add(top);
    path.insert(0, bottom);
    path.smooth();
}

function onMouseUp(event) {

    path.add(event.point);
    path.closed = true;
    path.smooth();
    path.remove();
    dragging = false;
    
    game.board.removeMarked();
}


    </script>

    </body>
</html>
